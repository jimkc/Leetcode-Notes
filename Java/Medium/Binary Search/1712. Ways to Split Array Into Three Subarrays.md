## Question
A split of an integer array is good if:  
  
* The array is split into three non-empty contiguous subarrays - named left, mid, right respectively from left to right.  
* The sum of the elements in left is less than or equal to the sum of the elements in mid, and the sum of the elements in mid is less than or equal to the sum of the elements in right.  

Given nums, an array of non-negative integers, return the number of good ways to split nums. As the number may be too large, return it modulo 109 + 7.  

**Example 1:**
<pre>
Input: nums = [1,1,1]
Output: 1
Explanation: The only good way to split nums is [1] [1] [1].
</pre>

**Example 2:**
<pre>
Input: nums = [1,2,2,2,5,0]
Output: 3
Explanation: There are three good ways of splitting nums:
[1] [2] [2,2,5,0]
[1] [2,2] [2,5,0]
[1,2] [2,2] [5,0]
</pre>

**Example 3:**
<pre>
Input: nums = [3,2,1]
Output: 0
Explanation: There is no good way to split nums.
</pre>

Constraints:
* 3 <= nums.length <= 105
* 0 <= nums[i] <= 104

## Thinking


## Coding
Time: O(nlog), we do binary search on each left pointer possibilities.
Space: O(1)
### Solution
```java
class Solution {
    public int waysToSplit(int[] nums) {
        int n = nums.length;
        long ans = 0;
        for (int i=1; i<n; i++) {
            nums[i] = nums[i-1] + nums[i];
        }

        // fix one pointer 
        for (int i=0; i<n-2; i++) {
            // another pointer use binary search to find
            // j~k are the range that satisfied both condition left<mid<right array
            int j = i + 1;
            // use n-2 as we at least need to leave one element in the right
            int right = n - 2;

            // after binary search j will be the smallest index that satisfy condition 1
            while (j <= right) {
                int mid = (j+right)/2;
                if (nums[mid] - nums[i] < nums[i]) {
                    j = mid + 1;
                } else {
                    // larger or equal
                    right = mid - 1;
                }
            }
            
            // binary search largest index satisfy for condition 2
            int k = j;
            right = n-2;
            while (k <= right) {
                int mid = (k + right)/2;
                // use <= so even if it is eual we will move pointer to right
                if (nums[mid] - nums[i] <= nums[n-1] - nums[mid]){
                    // move right even if it is equal as we are looking for the 
                    // largest index that satisfy condition 2
                    k = mid + 1;
                } else {
                    right = mid-1;
                }
            }
            ans  = (ans + k - j) % 1000000007;
        }
        return (int) ans;
    }
    
}
```