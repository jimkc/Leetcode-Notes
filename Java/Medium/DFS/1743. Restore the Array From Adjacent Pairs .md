## Question
There is an integer array nums that consists of n unique elements, but you have forgotten it. However, you do remember every pair of adjacent elements in nums.  
  
You are given a 2D integer array adjacentPairs of size n - 1 where each adjacentPairs[i] = [ui, vi] indicates that the elements ui and vi are adjacent in nums.  
  
It is guaranteed that every adjacent pair of elements nums[i] and nums[i+1] will exist in adjacentPairs, either as [nums[i], nums[i+1]] or [nums[i+1], nums[i]]. The pairs can appear in any order.  
  
Return the original array nums. If there are multiple solutions, return any of them.  
  
**Example 1:**
<pre>
Input: adjacentPairs = [[2,1],[3,4],[3,2]]
Output: [1,2,3,4]
Explanation: This array has all its adjacent pairs in adjacentPairs.
Notice that adjacentPairs[i] may not be in left-to-right order.
</pre>

**Example 2:**
<pre>
Input: adjacentPairs = [[4,-2],[1,4],[-3,1]]
Output: [-2,4,1,-3]
Explanation: There can be negative numbers.
Another solution is [-3,1,4,-2], which would also be accepted.
</pre>

**Example 3:**
<pre>
Input: adjacentPairs = [[100000,-100000]]
Output: [100000,-100000]
</pre>

Constraints:
* nums.length == n
* adjacentPairs.length == n - 1
* adjacentPairs[i].length == 2
* 2 <= n <= 105
* -105 <= nums[i], ui, vi <= 105
* There exists some nums that has adjacentPairs as its pairs.

## Thinking
https://leetcode.com/problems/restore-the-array-from-adjacent-pairs/solutions/1043371/java-bfs-or-dfs-code-intuition-visualisation

Build adjacent graph with double direction to make sure we are able to traverse all numbers, but use seen set to make sure we don't traverse dupliucate nodes.

## Coding
Time: O(n), go through each number once.  
Space: O(n).  
### Solution
```java
class Solution {
    public int[] restoreArray(int[][] adjacentPairs) {
        // store key as smaller, value as larger
        Map<Integer, List<Integer>> graph = new HashMap<>();

        for (int[] p: adjacentPairs) {
            // build graph on both direction as we don't know which one will be traverse first, we will use seen set to prevent duplicate visits
            addToGraph(graph, p[0], p[1]);
            addToGraph(graph, p[1], p[0]);
        }

        // find the boundary node to start traversal
        int start = 0;
        for (Integer key: graph.keySet()){
            if (graph.get(key).size() == 1) {
                start = key;
                break;
            }
        }

        List<Integer> ans = new ArrayList<>();
        Set<Integer> seen = new HashSet<>();
        dfs(graph, seen, ans, start);

        int[] res = new int[ans.size()];
        for (int i=0; i<ans.size(); i++) {
            res[i] = ans.get(i);
        }
        return res;
    }

    private void dfs(Map<Integer, List<Integer>> graph, Set<Integer> seen, List<Integer> ans, int num) {
        ans.add(num);
        seen.add(num);

        for (int curr: graph.get(num)){
            if (!seen.contains(curr)) {                
                dfs(graph, seen, ans, curr);
            }
        }
    }

    private void addToGraph(Map<Integer, List<Integer>> graph, int key, int value) {
        if (graph.containsKey(key)) {
            graph.get(key).add(value);
        } else {
            graph.put(key, new ArrayList<>());
            graph.get(key).add(value);
        }
    }
}
```