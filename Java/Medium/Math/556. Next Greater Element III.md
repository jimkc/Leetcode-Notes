## Question
Given a positive integer n, find the smallest integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive integer exists, return -1.

Note that the returned integer should fit in 32-bit integer, if there is a valid answer but it does not fit in 32-bit integer, return -1.

**Example 1:**
<pre>
Input: n = 12
Output: 21
</pre>

**Example 2:**
<pre>
Input: n = 21
Output: -1
</pre>

Constraints:
* 1 <= n <= 231 - 1


## Thinking
12532 ->  find peak is 5 and swap 2 with the first number larger than 2 from the right -> 13522 -> then reverse the 522 ->  13225. It is the same problem as finding the next permuation of a larger number.

## Coding
### Solution 
Time: O()  
Space: O()  
```java
class Solution {
    public int nextGreaterElement(int n) {
        // Convert to a character array for easy, in-place modifications.
        char[] digits = Integer.toString(n).toCharArray();

        int peakIndex = findPeak(digits);
        
        // If peakIndex is 0, the digits are in non-increasing order (e.g., 321).
        // No larger permutation is possible.
        if (peakIndex == 0) {
            return -1;
        }

        // The pivot is the character just before the peak.
        int pivotIndex = peakIndex - 1;
        char pivotChar = digits[pivotIndex];
        
        // Find the smallest digit to the right of the pivot that is larger than the pivot.
        int swapIndex = findNextLarger(pivotChar, digits, peakIndex);

        // Swap the pivot with the found digit.
        swap(pivotIndex, swapIndex, digits);
        
        // **[FIX #1]** Reverse the suffix after the pivot's original position.
        reverse(digits, peakIndex);

        // **[FIX #2 & #3]** Convert the result back to a number and check for 32-bit integer overflow.
        try {
            long result = Long.parseLong(new String(digits));
            if (result > Integer.MAX_VALUE) {
                return -1; // Overflow
            }
            return (int) result;
        } catch (NumberFormatException e) {
            return -1;
        }
    }

    // Helper to find the first character from the right that is smaller than its neighbor to the right.
    // (No changes needed to the logic, just the type of the parameter).
    private int findPeak(char[] s){
        for(int i = s.length - 1; i > 0; i--) {
            if (s[i-1] < s[i]){
                return i;
            }
        }
        return 0;
    }

    // Helper to find the rightmost character that is larger than m.
    // We start the search from the right end.
    private int findNextLarger(char m, char[] s, int start) {
        for (int i = s.length - 1; i >= start; i--) {
            if (m < s[i]){
                return i;
            }
        }
        return -1;
    }

    // Helper to swap two characters in an array.
    // It now modifies the array directly and doesn't need to return anything (void).
    private void swap(int i, int j, char[] chars){
        char tmp = chars[i];
        chars[i] = chars[j];
        chars[j] = tmp;
    }
    
    // **[NEW HELPER]** Helper to reverse a part of the array from a starting index to the end.
    private void reverse(char[] chars, int start) {
        int left = start;
        int right = chars.length - 1;
        while (left < right) {
            swap(left, right, chars);
            left++;
            right--;
        }
    }
}
```
