## Question
You are given an array of CPU tasks, each labeled with a letter from A to Z, and a number n. Each CPU interval can be idle or allow the completion of one task. Tasks can be completed in any order, but there's a constraint: there has to be a gap of at least n intervals between two tasks with the same label.  
  
Return the minimum number of CPU intervals required to complete all tasks.  
  
**Example 1:**
<pre>
Input: tasks = ["A","A","A","B","B","B"], n = 2

Output: 8

Explanation: A possible sequence is: A -> B -> idle -> A -> B -> idle -> A -> B.

After completing task A, you must wait two intervals before doing A again. The same applies to task B. In the 3rd interval, neither A nor B can be done, so you idle. By the 4th interval, you can do A again as 2 intervals have passed.
</pre>

**Example 2:**
<pre>
Input: tasks = ["A","C","A","B","D","B"], n = 1

Output: 6

Explanation: A possible sequence is: A -> B -> C -> D -> A -> B.

With a cooling interval of 1, you can repeat a task after just one other task.
</pre>

**Example 3:**
<pre>
Input: tasks = ["A","A","A", "B","B","B"], n = 3

Output: 10

Explanation: A possible sequence is: A -> B -> idle -> idle -> A -> B -> idle -> idle -> A -> B.

There are only two types of tasks, A and B, which need to be separated by 3 intervals. This leads to idling twice between repetitions of these tasks.
</pre>

Constraints:
* 1 <= tasks.length <= 104
* tasks[i] is an uppercase English letter.
* 0 <= n <= 100

## Thinking
https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/2734162/java-c-python-binary-search


## Coding
Time: O(nlog(n))  
Space: O(1)
### Solution
```java
class Solution {
    public long minCost(int[] nums, int[] cost) {
        long left = nums[0];
        long right = nums[0];
        for (int n: nums){
            left = Math.min(left, n);
            right = Math.max(right, n);
        }

        // trinary search
        long ans = 0;
        while (left < right) {
            long mid = left + (right - left)/2;
            long cost1 = findCost(nums, cost, mid);
            long cost2 = findCost(nums, cost, mid+1);

            if (cost1 > cost2) {
                left = mid+1;
                ans = cost2;
            } else {
                right = mid;
                ans = cost1;
            }
        }
        return ans;
    }

    private long findCost(int[] nums, int[] cost, long x){
        long res = 0;

        for (int i=0; i<nums.length; i++) {
            res += Math.abs(nums[i]-x)*cost[i];
        }
        return res;
    }
}
```