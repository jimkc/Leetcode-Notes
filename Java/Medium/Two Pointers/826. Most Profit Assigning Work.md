## Question
You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:  
  
* difficulty[i] and profit[i] are the difficulty and the profit of the ith job, and  
* worker[j] is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most worker[j]).

Every worker can be assigned at most one job, but one job can be completed multiple times.

* For example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0.

Return the maximum profit we can achieve after assigning the workers to the jobs.

**Example 1:**
<pre>
Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]
Output: 100
Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately.
</pre>

**Example 2:**
<pre>
Input: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]
Output: 0
</pre>

Constraints:
* 1 <= s.length <= 15
* s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').
* It is guaranteed that s is a valid roman numeral in the range [1, 3999].

## Thinking
https://leetcode.com/problems/most-profit-assigning-work/solutions/5328902/most-profit-assigning-work

Sort difficulty and workers max difficulaty. Use variable to keep track of the current max profit from index 0 to index i with increasing difficulty. That way we can use two pointers to move one by one and keep track of the max profit.

## Coding
### Solution - Optimal
Time: O(n+m), n is profit length m is worker length  
Space: O(n)  
```java
class Solution {
    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {
        // find the job with the most profit but lesser dificulty for each worker

        int n = profit.length;
        int[][] jobs = new int[n][2];

        for (int i=0; i<n; i++) {
            jobs[i] = new int[]{difficulty[i], profit[i]};
        }
        // sort by dificulty
        Arrays.sort(jobs, (a, b) -> (a[0] - b[0]));
        Arrays.sort(worker);
        int jp = 0;
        int wp = 0;

        int maxCurrProfit = 0;
        int totalMaxProfit = 0;
        int index = 0;
        for (int i=0; i<worker.length; i++) {
            while (index < n) {
                int currDiff = jobs[index][0];
                int currProfit = jobs[index][1];
                if (worker[i] >= currDiff) {
                    maxCurrProfit = Math.max(maxCurrProfit, currProfit);
                    index++;
                } else {
                    break;
                }
            }
            totalMaxProfit += maxCurrProfit;
        }
        return totalMaxProfit;
    }
}
```

## Coding
### Solution - Binary search
Use binary search to find the current worker's max difficulty and go through the corresponding profit array until the index to find max profit.

```java
class Solution {

    public int maxProfitAssignment(
        int[] difficulty,
        int[] profit,
        int[] worker
    ) {
        List<int[]> jobProfile = new ArrayList<>();
        jobProfile.add(new int[] { 0, 0 });
        for (int i = 0; i < difficulty.length; i++) {
            jobProfile.add(new int[] { difficulty[i], profit[i] });
        }

        // Sort by difficulty values in increasing order.
        Collections.sort(jobProfile, (a, b) -> Integer.compare(a[0], b[0]));
        for (int i = 0; i < jobProfile.size() - 1; i++) {
            jobProfile.get(i + 1)[1] = Math.max(
                jobProfile.get(i)[1],
                jobProfile.get(i + 1)[1]
            );
        }

        int netProfit = 0;
        for (int i = 0; i < worker.length; i++) {
            int ability = worker[i];

            // Find the job with just smaller or equal difficulty than ability.
            int l = 0, r = jobProfile.size() - 1, jobProfit = 0;
            while (l <= r) {
                int mid = (l + r) / 2;
                if (jobProfile.get(mid)[0] <= ability) {
                    jobProfit = Math.max(jobProfit, jobProfile.get(mid)[1]);
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }

            // Increment profit of current worker to total profit.
            netProfit += jobProfit;
        }
        return netProfit;
    }
}
```

